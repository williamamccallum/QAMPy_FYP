"""
Testing ground for being able to generate a signal, send to AWG, read in from oscilloscope and perform recovery
Author: William McCallum
Last updated: 19/5/22
"""

import numpy as np
import matplotlib.pylab as plt
from qampy import equalisation, signals, impairments, helpers
from qampy.core.equalisation.pythran_equalisation import apply_filter_to_signal
from bokeh.plotting import figure, show
from timeit import default_timer as timer
import math
import pyvisa

import os
import socket


def sin(sig_len, freq, sample_rate, amp, phase):
    t = np.linspace(0, sig_len / sample_rate, num=sig_len, endpoint=False)
    sin_sig = np.zeros(len(t))
    for i in range(len(t)):
        sin_sig[i] = amp * math.sin(2 * math.pi * t[i] * 2 * 10 ** 9 + phase)
    return [sin_sig, t]


def qampy_sig(sig_len=2 ** 17, freq=40.e9, fs=40.e9, m_qam=16, n_modes=2, os=1, snr=0):
    """
    Generates a QAMpy signal and converts it into a format that can be easily saved to be read in to the AWG
    :param: sig_len: gives how many data points there are in the signal
    :param: freq: symbol rate of the signal
    :param: m_qam: gives the QAM order of the signal (eg. m_qam = 16 means 16-QAM)
    :param: n_modes: if 1, then only use X polarisation, if 2, use both X and Y polarisations
    :param: os: freq*os = sampling rate of the signal
    :param: snr: gives the SNR of the signal, if snr=0, then no noise is applied to the signal
    :return: sig: the signal generated by QAMpy converted into an array with each row corresponding to 1 channel in the AWG
    """
    # qam_sig = signals.SignalQAMGrayCoded(m_qam, sig_len, nmodes=n_modes, fb=freq)
    qam_sig = signals.ResampledQAM(m_qam, sig_len, nmodes=2, fb=freq, fs=fs,
                                   resamplekwargs={"beta": 0.01, "renormalise": True})
    if snr != 0:
        qam_sig = impairments.change_snr(qam_sig, snr)

    # convert qam_signal to an easily readable format, ie. arr(4, sig_len)
    sig = np.zeros(shape=(n_modes * 2, len(qam_sig[0])))
    for i in range(n_modes):
        sig[i * 2] = (qam_sig[i].real)
        sig[i * 2 + 1] = (qam_sig[i].imag)
    return sig


def saveToFile(arr, seg_len, n_modes=1, complex=False, filename="test_sig.txt"):
    """
    Saves an array for use in AWG to a file to be uploaded
    :param: arr: an array of waveform data that is to be run on an AWG
    :param: seg_len: The length of a segment in the waveform. Note that the file length should be a multiple of this value
    :param: n_modes: gives the number of polarisations of the signal, ie. 1 if only X component, 2 if both X and Y components
    :param: complex: if True, the signal has both real and complex components, else it only has real components
    :param: filename: The name of the file that the data is to be saved to
    :return: filenames: a list of all of the filenames that were saved to
    """

    if n_modes > 2:  # should be only 1 or 2 modes (for X and Y polarisations)
        n_modes = 2
    elif n_modes != 1 and n_modes != 2:
        n_modes = 1

    file_append = ['XI.txt', 'XQ.txt', 'YI.txt',
                   'YQ.txt']  # to be added to end of filename if there is more than 1 file
    filename = filename.rstrip(".txt")  # removes .txt from end of file so that subheadings can be added

    if n_modes == 1 and not complex:
        filename = filename + ".txt"
        file = open(filename, "w")
        file.write("0,1,1\n")
        for i in range(len(arr)):  # for each data point
            if ((i + 1) % seg_len) == 0:  # if start of segment
                file.write("%.16f,1,1\n" % arr[i])
            else:
                file.write("%.16f,0,0\n" % arr[i])
        file.close()
        return [filename]

    else:
        n_files = n_modes * (int(complex) + 1)  # gets number of files to be built from signal
        filenames = [filename] * n_files  # stores list of filenames for data to be saved to
        for i in range(n_files):
            if n_modes == 1:  # only X components
                filenames[i] += file_append[i * 2]
            elif n_modes == 2:  # both X and Y components
                filenames[i] += file_append[i]
            with open(filenames[i], 'w') as file:
                for j in range(len(arr[i])):  # for each data point
                    if (j % seg_len) == 0:  # if start of segment
                        file.write("%.16f,1,1\n" % arr[i, j])
                    else:
                        file.write("%.16f,0,0\n" % arr[i, j])
        return filenames


def checkFile(filename):
    count1 = 0
    count = 0
    with open(filename, "r") as file:
        for line in file:
            end_str = line.rstrip()[-1:]
            if end_str == "1":
                print("1 at line %d" % count)
                count1 += 1
            count += 1
    ratio = count1 / count
    print("ratio is %.6f" % ratio)
    print("num of 1's is %d" % count1)
    return [count, count1, ratio]


def getDataFromOsc(osc, channels=None, MAX_LENGTH=1e4):
    """
    Gets the waveform data from the oscilloscope and stores it in a 2D list
    :param osc: oscilloscope VISA resource
    :param channels: list of all channels to be read
    :param MAX_LENGTH: Maximum length of data to be read from the oscilloscope for each channel
    :return:
    """
    if channels is None:
        channels = [1]
    data = []

    # sets transfer formats
    osc.write(":WAVeform:FORMat ASCii")  # sends data as 16-bit signed ints
    osc.write(":WAVeform:BYTeorder LSBFirst")  # sends LSB first
    osc.write(":WAVeform:STReaming 0")  # turns on waveform streaming of data
    osc.write(":SYSTem:HEADer OFF")  # turns off system headers to allow numeric data to be read correctly

    for i in range(len(channels)):
        osc.write(":WAVeform:SOURce CHANnel%d" % channels[i])  # defines which channel is to be read from
        # osc.write(":DIGitize CHANnel%d" % channels[i])                  # digitizes channel to make it easier to read
        # osc.write(":CHANnel%d:DISPlay ON" % channels[i])                # turns channel display back on, as digitize turns it off automatically

        # get voltage and time conversion factors
        xInc = osc.query(":WAVeform:XINCrement?")
        xOrg = osc.query(":WAVeform:XORigin?")
        yInc = osc.query(":WAVeform:YINCrement?")
        yOrg = osc.query(":WAVeform:YORigin?")

        # get waveform info
        wave_points = int(osc.query(":wav:points?"))
        print("number of points: %d" % wave_points)
        # block_size = int(min(math.pow(math.ceil(math.log(wave_points, 2)), 2), MAX_LENGTH))
        block_size = MAX_LENGTH
        block_count = int(max(1, wave_points / block_size))
        print("block count: %d" % block_count)
        tmp_data = np.zeros(shape=(wave_points + 1, 1))
        x_list = []
        for block_num in range(block_count):
            # print("block %d" % block_num)
            start_point = int(block_num * block_size + 1)  # start point of current block
            # print("start: %d" % start_point)
            end_point = int(min(start_point + block_size - 1, wave_points))  # end point of current block
            # print("end : %d" % end_point)
            size = end_point - start_point + 1
            # print("block size: %d" % size)
            x = osc.query(":WAVeform:DATA? %d,%d" % (start_point, size))
            x_list.extend(x.split(","))
            # print(x)
            # tmp_data[start_point:end_point] = osc.query(":WAVeform:DATA? %d,%d" % (start_point, size))   # requests data from the oscilloscope
        tmp_data = convertToFloat(x_list)
        data.append(tmp_data[1:])

        # find # and 0 chars
        # start_found = False
        # curr_char = 0
        # while not start_found:
        # read a byte, and check that it is the current byte to be found, if it is move onto next char to be found
        # once all chars have been found, move on to reading data

    # osc.write(":SYSTem:HEADer ON")      # turns system headers back on
    return data


def convertToFloat(string_list):
    # string_list = string.split(",")
    converted_data = np.zeros(shape=len(string_list) - 1)
    # print(len(string_list))
    i = 0
    while i < len(string_list):
        # X.XXXXE+09
        tmp = string_list[i].split("E")
        # print(tmp)
        if tmp[0] != "\n":
            converted_data[i] = float(tmp[0]) * pow(10, int(tmp[1]))
            # print(converted_data[i])
        i += 1
    return converted_data


def convertToQAMpyWaveform(data, freq, fs, m_qam=16, n_modes=2):
    # Takes a waveform formatted as a list and converts it into a QAMpy waveform
    #:param data: a 2d list of waveform points, should be either 1, 2, or 4 sets of data
    #:param freq: The symbol rate of the signal
    #:param fs: the sample rate of the oscilloscope
    #:param m_qam: the QAM-order of the signal
    #:return: a QAMpy gray-coded signal object
    n_sets = len(data)
    sig_len = len(data[0])
    if n_sets == 4:  # has both X & Y components and complex data
        sig = signals.SignalQAMGrayCoded(m_qam, sig_len, nmodes=2, fb=freq)
        X = np.empty(len(data[0]), dtype=np.complex128)
        Y = np.empty(len(data[0]), dtype=np.complex128)
        X.real = data[0]
        X.imag = data[1]
        Y.real = data[2]
        Y.imag = data[3]

        sig[0] = X
        sig[1] = Y
    # elif n_sets == 2 and n_modes == 2:  # has both X & Y components but only real data

    # elif n_sets == 2 and n_modes == 1:  # has only X component and complex data

    return sig


def sendFile(filename, server_ip, server_port, BUFFER_SIZE=4096):
    """
    Sends a file to a remote server
    :param filename: the name of the file that is to be sent
    :param server_ip: the IP address of the server
    :param server_port: server port to send file to
    :param BUFFER_SIZE: Maximum number of bytes that can be sent at once
    :return:
    """
    # gets the size of the file that is to be sent
    filesize = os.path.getsize(filename)
    SEPARATOR = "<SEPARATOR>"

    # attempt to connect to remote server
    remote = socket.socket()
    print(f"[+] Connecting to {server_ip}:{server_port}")
    remote.connect((server_ip, server_port))
    print("[+] Connected.")

    # send file details to server
    remote.send(f"{filename}{SEPARATOR}{filesize}".encode())

    # send file to server
    with open(filename, 'rb') as file:
        while True:
            # read the bytes from the file
            bytes_read = file.read(BUFFER_SIZE)
            if not bytes_read:
                # file transmitting is done
                break
            remote.sendall(bytes_read)
    # close socket
    remote.close()
    return


def plot_constellation(E, title="QPSK signal constellation"):
    """
    Plots signal in a constellation diagram
    """
    fig = figure(title=title, output_backend="webgl")
    fig.scatter(E[0].real, E[0].imag, color='red', alpha=0.3)
    fig.scatter(E[1].real, E[1].imag, color='blue', alpha=0.3)
    fig.xaxis[0].axis_label = "In-Phase"
    fig.yaxis[0].axis_label = "Quadrature"
    show(fig)


if __name__ == "__main__":
    # sig_type = ["sin", "qam"]
    channels = [1, 2, 3, 4]
    sig_num = 1  # if sig_num = 0, use sine waveform, elif sig_num = 1, use QAM signal
    gen_sig = False
    send_to_awg = False
    receive_from_oscilloscope = True
    recover_signal = True
    output_results = False

    awg_name = 'TCPIP0::inst1::INSTR'  # gives the VISA name of the AWG
    osc_name = 'TCPIP0::inst0::INSTR'  # gives the VISA name of the oscilloscope
    server_ip = "192.168.0.1"
    server_port = "5001"
    seg_len = 64  # length of a segment of the signal
    if gen_sig:
        if sig_num == 0:
            # generate sine wave
            sig_len = int(1000 * seg_len - 1)
            freq = 10 * 10 ** 6
            sample_rate = 64 * 10 ** 9
            phase = 0
            amp = 1
            [sig, t] = sin(sig_len, freq, sample_rate, amp, phase)
            # plt.plot(t, sin_arr)
            # plt.show()

            # save sine wave to file
            saveToFile(sig, seg_len, filename="sin_wave")
            checkFile("sin_wave.txt")
            # checkFile("D:\WaveformDataFiles\Sin10MHzAt64GHz.txt")

        elif sig_num == 1:
            # generate qampy signal
            fb = 10.e9  # baud rate
            os = 6
            fs = fb * os  # sampling rate
            N = 100 * seg_len  # number of symbols
            M = 64  # M-QAM
            snr = 0
            n_modes = 2
            sig = qampy_sig(N, fb, fs, M, n_modes, os, snr)
            print(sig)
            freq = np.linspace(-30, 30, num=len(sig[0]), endpoint=False)

            c = np.empty(len(sig[0]), dtype=np.complex128)
            c.real = sig[0]
            c.imag = sig[1]
            sp = abs(np.fft.fft(c))
            sp = np.fft.fftshift(sp)
            plt.plot(freq, sp.real, freq, sp.imag)
            plt.show()

            # build files from QAMpy signal
            saveToFile(sig, seg_len, n_modes=2, complex=True, filename="qam_sig")

    if send_to_awg:
        # access AWG
        rm = pyvisa.ResourceManager()
        available_instruments = rm.list_resources()
        # check if awg is reachable
        if awg_name in available_instruments:
            awg = rm.open_resource(awg_name)  # open connection to AWG
            print(awg.query('*IDN?'))  # confirm that communication is possible

            # upload files to computer (use sockets)
            sendFile("qam_sigXI.txt", server_ip, server_port)

            # run file
            # awg.write(':TRAC1:IMP 1, "C:\Sin10MHzAt64GHz.bin", BIN, IONLY, ON, ALEN')
            awg.write(':TRAC1:IMP 1, "C:\sin_wave - Copy.txt", TXT, IONLY, ON, ALEN')

            # close connection to AWG
            awg.close()
        else:
            print(
                "AWG not found in list of available resources, check that it is connected and its current VISA address is correct")

    if receive_from_oscilloscope:
        if not send_to_awg:
            rm = pyvisa.ResourceManager()
            available_instruments = rm.list_resources()

        if osc_name in available_instruments:
            # Access oscilloscope
            osc = rm.open_resource(osc_name)
            print(osc.query('*IDN?'))

            # get data file from oscilloscope
            try:
                sig = getDataFromOsc(osc, channels=[1, 2, 3, 4])
                # convert sig data to QAMpy signal
                print(sig)
                print("signal length: %d" % len(sig[0]))
                print("signal channels %d" % len(sig))

                # close connection to oscilloscope
                osc.close()
            except:
                print("Error in getting signal from oscilloscope. Closing connection")
                osc.close()


        else:
            print(
                "Oscilloscope could not be found in list of available instruments. Please check that it is connected and its address in code matches its address in the network and try again")

    if recover_signal:
        # get fft of signal
        freq = np.linspace(-40, 40, num=len(sig[0]), endpoint=False)
        c = np.empty(len(sig[0]), dtype=np.complex128)
        c.real = sig[0]
        c.imag = sig[1]
        sp = abs(np.fft.fft(c))
        sp = np.fft.fftshift(sp)
        sp = sp * 20
        sp = np.array([math.log(x, 10) for x in sp])
        plt.plot(freq, sp.real, freq, sp.imag)
        plt.show()

        # run recovery
        fb = 15e9
        fosc = 80e9
        m_qam = 16

        sig = convertToQAMpyWaveform(sig, fb, fosc, m_qam, n_modes=2)
        plot_constellation(sig)

    # if output_results:
    # output results
